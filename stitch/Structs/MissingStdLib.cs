using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Stitch {
    /// <summary>
    /// An option type heavily inspired by the Rust standard library.
    /// </summary>
    public struct Option<T> {
        T value = default(T);
        bool valid = false;

        /// <summary> Create a None (or an option without any value). </summary>
        public Option() { }
        /// <summary> Create an option with a containing value (a Some). </summary>
        /// <param name="val"> The value inside this option. </param>
        public Option(T val) {
            value = val;
            valid = true;
        }

        /// <summary> Unwrap the option throwing an error when there is no value inside.</summary>
        /// <exception cref="NullReferenceException">When there is no value in this Option.</exception>
        /// <returns>The inner value if applicable.</returns>
        public T Unwrap() {
            if (!valid)
                throw new NullReferenceException("None was unwrapped in an option");
            return value;
        }

        /// <summary> Unwrap the option throwing an error when there is no value inside. With a custom message. </summary>
        /// <exception cref="NullReferenceException">When there is no value in this Option.</exception>
        /// <returns>The inner value if applicable.</returns>
        public T Unwrap(string msg) {
            if (!valid)
                throw new NullReferenceException(msg);
            return value;
        }

        /// <summary> Unwrap the option or use the default provided.</summary>
        /// <returns>The inner value or the default value.</returns>
        public T Unwrap(T def) {
            if (!valid)
                return def;
            return value;
        }

        /// <summary> Change the inner value in the option with the callback.</summary>
        /// <param name="f">The callback function to change the inner value of the Option with.</param>
        /// <typeparam name="O">The resulting type of the value transformation.</typeparam>
        /// <returns>A new option with possibly a new value.</returns>
        public Option<O> Map<O>(Func<T, O> f) {
            if (!valid)
                return new Option<O>();
            return new Option<O>(f(value));
        }

        /// <summary> Change the inner value in the option with the callback.</summary>
        /// <param name="f_some">The callback function to change the inner value of the Option with.</param>
        /// <param name="f_none">The callback function to create a new value of type O.</param>
        /// <typeparam name="O">The resulting type of the value transformation.</typeparam>
        /// <returns>The new value either created from the old value or generated by <ref cref="f_none">f_none</ref>.</returns>
        public O Map<O>(Func<T, O> f_some, Func<O> f_none) {
            if (!valid)
                return f_none();
            return f_some(value);
        }
    }
}
